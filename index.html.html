<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="favicon.png" rel="shortcut icon" type="image/png">
<font face="MV BOLI"; size="4">
	<title> Яндекс.Блог </title>
</head>
	<body style="margin-left: 1%;" bgcolor="#00FFFF">

 <marquee direction="right";scrollamount="3">
	<h1 align="center">Блог компании Yandex</h1>
	</marquee>
</font>
	<p align="center"><b>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ.</b></p>

<div>
	<p>Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,
		какой он красивый, ни то, какой он удобный. Никому не понравится, когда все
		тормозит.<br> Мы регулярно добавляем в Яндекс.Почту новую функциональность,
		иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код
		и новая логика.<br> Всё это напрямую влияет на скорость работы интерфейса.</p></div>

	<h2 align="center">Что мы измеряем</h2>
<div>		
		<ol <p> <b>Этапы первой загрузки:</b></p>
		<li>подготовка;</li>
		<li>загрузка статики (HTTP-запрос и парсинг);</li>
		<li>исполнение модулей;</li>
		<li>инициализация базовых объектов;</li>
		<li>отрисовка.</li>
	</ol><br></div>

	<ol <p><strong>Этапы отрисовки любой страницы:</strong></p> 
			<li>подготовка к запросу на сервер;</li>
			<li>запрос данных с сервера;</li>
			<li>шаблонизация;</li>
			<li>обновление<a href="https://ru.wikipedia.org/wiki/Document_Object_Model" target="_blank"> DOM</a></li>
		</ol><br>
<div style="text-align: left;">
		<blockquote><b><pre>— «Ок, теперь у нас есть метрики, мы можем отправить их на сервер» - говорим мы
— «Что же дальше?» - вопрошаете вы
— «А давай построим график!» - отвечаем мы
— «А что будем считать?» - уточняете вы
</pre></b></blockquote></div>
<div>
		<p>Как вы знаете, медиана – это серединное, а не среднее значение в выборке.
		Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.<br>
		В общем случае медиана отлично показывает, сколько грузится средний пользователь.<br>
		В случае ускорения или замедления медиана, конечно, изменится.<br> Но она не может
		рассказать, сколько пользователей ускорилось, а сколько замедлилось.</p></div>	
<div>
		<p>
			<img src="https://upload.wikimedia.org/wikipedia/en/b/b0/Apdex_Logo.PNG"  alt="imeg">
		</p>
		<p><span><a href="https://en.wikipedia.org/wiki/Apdex" target="_blank" >APDEX</a></span> – метрика, которая сразу говорит: хорошо или плохо. <br>Метрика
			работает очень просто. Мы выбираем временной интервал [0; t], такой, что если
			время показа страницы попало в него, то пользователь счастлив.<br> Берем еще один
			интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница
			показана за это время, то пользователь в целом удовлетворен<br> скоростью работы,
			но уже не настолько счастлив.<br> И применяем формулу:<br>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
       		Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
       		хорошо или плохо работает почта.</p></div>	
	<h2 align="center">Как мы измеряем</h2>
<div>
		<p>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять
		причину замедления:<br> медленнее стал отвечать сервер либо слишком долго
		выполняется <span><a href="https://ru.wikipedia.org/wiki/JavaScript" target="_blank">JavaScript</a></span><br> Выглядит это примерно так:</p>
		<code><pre style="color:#FF4500; background: #000000; border: 1px solid #08088A; width: 400px; padding: 3px;" align="center">this.timings['look-ma-im-start'] = Date.now();
this.timings['look-ma-finish'] = Date.now();</pre></code><br>
		<p>C помощью Date.now() мы получаем текущее время. Все тайминги собираются и при
		отправке рассчитываются. На этапах разница между “end” и “start” не считается,
		а все вычисления производятся в конце:</p>
		<code style="color:#FF4500; background: #000000; border: 1px solid #08088A; width: 400px; padding: 3px;" align="center">var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code>
		<p>И на сервер прилетают подобные записи:</p>
		<code style="color:#FF4500; background: #000000; border: 1px solid #08088A; width: 400px; padding: 3px;" align="center">serverResponse=50&domUpdate=60</code>
		</div>	
	<h2 align="center">Как мы ускоряем</h2>
<div>
	<ol <p><b>Чтобы снизить время загрузки почты при выходе новых версий,
				мы уже делаем следующее:</b></p>
		<li>включаем gzip;</li>
		<li>выставляем заголовки кэширования;</li>
		<li>фризим CSS, JS, шаблоны и картинки;</li>
		<li>используем CDN</li>
	</ol></div>
<div>
	<p>Мы подумали: «А что если хранить где-то старую версию файлов, а при выходе новой
		передавать только diff между ней и той, которая сохранена у пользователя?»<br>
		В браузере же останется просто наложить патч на клиенте.</p>
	
	<p>На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например,
		RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они<br>
		не получили должного распространения в браузерах и на серверах.</p>
	
	<p>Мы же решили сделать свой аналог на JS.<br> Чтобы реализовать этот метод обновления,
		начали искать реализации diff на JS. На популярных хостингах кода нашли
		библиотеки:<br>
		
		<code>- VCDiff<br>
		- google-diff-patch-match</code></p>
		<p>Для окончательного выбора библиотеки нам нужно сравнить:</p>
		<table border="2"> 
		  <thead>   
        <tr><!-- strokes-->
            <th>Библиотека</th> <!--colums-->
            <th>IE 9</th>
            <th>Opera 12</th>
           </tr>   
    	</thead> 
        <tr bgcolor="#F4A460"><td>vcdiff</td><td>8</td><td>5</td></tr>
        <tr bgcolor="#F4A460"><td>google diff</td><td>1363</td><td>76</td></tr>
        </table> 
		</div>	
<div><p>После того как мы определились с библиотекой для диффа, нужно определиться с тем,
		где и как хранить статику на клиенте.<br>
		Формат файла с патчами для проекта выглядит так:<br>
		<code>
    	<pre style="color:#FF4500; background: #000000; border: 1px solid #08088A; width: 200px; padding: 3px;">[
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    },
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    }
]
</pre>
	</code><br>
		</p>
	</div>		
<div>
	<p>То есть это обычный массив из объектов. Каждый объект — отдельный ресурс.<br> У
		каждого объекта есть три свойства.<br> k — названия ключа в localStorage для этого
		ресурса.<br> p — патч для ресурса, который сгенерировал vcdiff.<br> s — чексумма для
		ресурса актуальной версии, чтобы потом можно было проверить правильность
		наложения патча на клиенте. <br>Чексумма вычисляется по алгоритму Флетчера.</p>
	<p><a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%91%D1%80%D0%BE%D0%B9%D0%B4%D0%B5%D0%BD%D0%B0_%E2%80%94_%D0%A4%D0%BB%D0%B5%D1%82%D1%87%D0%B5%D1%80%D0%B0_%E2%80%94_%D0%93%D0%BE%D0%BB%D1%8C%D0%B4%D1%84%D0%B0%D1%80%D0%B1%D0%B0_%E2%80%94_%D0%A8%D0%B0%D0%BD%D0%BD%D0%BE"><b>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)</b></a><br>
		— итерационный метод численной оптимизации, предназначенный для
		нахождения локального максимума/минимума нелинейного функционала
		без ограничений.</p>
		<img src="http://trond.hjorteland.com/thesis/img262.gif">

		<p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:<br>
		CRC16/32 - алгоритм нахождения контрольной суммы, предназначенный для проверки
		целостности данных<br>
		md5 - 128-битный алгоритм хеширования. Предназначен для создания «отпечатков»
		или дайджестов сообщения произвольной длины и последующей проверки
		их подлинности.<br>Потому что он быстрый, компактный и легок в реализации.</p></div>

<h2 align="center">Итог</h2>		
<div>
	<table border="2">
		<p>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</p>
		 <thead>   
        <tr><!-- strokes-->
            <th>Релиз</th> <!--colums-->
            <th>С патчем</th>
            <th>Без патча</th>
           </tr>   
    	</thead> 
        <tr bgcolor="#FF4500"><td>7.7.20</td><td>397</td><td>174 549</td></tr>
        <tr bgcolor="#FF4500"><td>7.7.21</td><td>383</td><td>53 995</td></tr>
        <tr bgcolor="#FF4500"><td>7.7.22</td><td>483</td><td>3 995</td></tr>
	</table></div><br>
<div>
	<p>Автор: @doochik<br>
	С++ разработик<br>
	<span>Электронная почта:<a href="mailto:doochik@yandex-team.ru">(doochik@yandex-team.ru)</a></span><br>
	Компания: Яндекс</p></div>

<div style="background: #E4E4E4; border: 1px solid #08088A; width: 850px;">
	<blockquote> <p><font face="Arial">Комментарии(3):</p>
	<p>- Mogaika <a href="mailto:mogaika@yandex-team.ru">(mogaika@yandex-team.ru)</a> 30 ноября 2014 в 17:05</p>
  	<p>А можете привести сравнение, на сколько быстрее грузится lite версия?</p><br>
	<p>- JIguse <a href="mrawesome@yandex.ru">(mrawesome@yandex.ru)</a> 29 ноября 2014 в 21:30</p>
  	<p>Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми
 	подробностями о внутренней работе сервисов.</p><br>
	<p>- Brister <a href="mailto:brist89@yandex-team.ru">(brist89@yandex-team.ru)</a> 24 ноября 2014 в 13:13</p>
  	<p>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
  	Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
  	хорошо или плохо работает почта.</p>
	<p> наверное все-таки от 0.5 до 1</p><br>
	<p>- alexeimois <a href="mailto:test@yandex.ru">(test@yandex.ru)</a> 22 ноября 2014 в 17:35</p>
	<p> Мы измеряем скорость загрузки с помощью Яндекс.Метрики:
  	<a href="help.yandex.ru/metrika/reports/monitoring_timing.xml">help.yandex.ru/metrika/reports/monitoring_timing.xml</a></p>
	</blockquote>
</div>	
 <p><b>&#169; Яндекс, help@yandex.ru, Хохрякова, 10</b></p>
	</body>
</html>